## This script follows the matrix population model methods in Crouse 1987 to produce equivalent analyses.

## Reference
## Title: A Stage-Based Population Model for Loggerhead Sea Turtles and Implications for Conservation
## Author(s): Deborah T. Crouse, Larry B. Crowder and Hal Caswell
## Source: Ecology, Vol. 68, No. 5 (Oct., 1987), pp. 1412-1423
## Published by: Ecological Society of America
## Stable URL: http://www.jstor.org/stable/1939225

rm(list=ls())

createProjectionMatrix <- function (surv, fec, d = NULL) {
    ## Create a stage-based population projection matrix

    ## Args:
    ##   surv: Stage-based survivorship estimates.
    ##   fec: Stage-based fecundity estimates.
    ##   d: Length of stages. If NULL the matrix reduces to an age-based projection matrix (Leslie matrix).

    ## Returns: Projection matrix A in which diagonal elements indicate the
    ## probability of remaining in a given stage; sub-diagonal elements indicate
    ## the probability of surviving and growing into the next stage; and the
    ## first row indicates the contribution to newborns from each stage.

    dimA <- length(surv)
    ## expect fec to have same length
    if (length(fec) != dimA)
        stop("expecting equal length survival and fecundity estimates")

    if (is.null(d)) {
        d <- rep(1, dimA)
    } else if (length(d) != dimA) {
        stop("expecting equal length survival and stage length vectors")
    }

    if(any(surv==1)) {
        warning("replacing survivorship values of 1 with 0.999 to avoid NaNs")
        surv[surv==1] = 0.999
    }

    # Calculate P (survival transition) and G (growth transition) values
    P <- ((1 - surv^(d-1))/(1 - surv^d))*surv  # See Crouse 1987, Eq. (1)
    G <- (surv^d*(1 - surv))/(1 - surv^d)  # See Crouse 1987, Eq. (2)

    # Create the projection matrix and set the diagonal to P.
    A <- diag(P)

    # Set the sub-diagonal to G (discarding the last value which is spurious because
    # the last stage is absorbing).
    diag(A[-1,-dimA]) <- G[1:(dimA-1)]

    # Set the first row to the fecundity values, eliding the first entry which we assume
    # corresponds to a non-reproductive stage.
    A[1,2:dimA] <- fec[2:dimA]

    return(A)
}

library(dplyr)
library(ggplot2)
library(gridExtra)

turtleData <- read.csv("~/Projects/popmod/crouse/loggerhead.crouse1987.csv") %>%
    mutate(stage.length = max.age - min.age)

A <- with(turtleData, createProjectionMatrix(surv, fecund, stage.length))
A

## Crouse 1987 calculates the eigenvalues and eigenvectors using the power
## method (Searle 1966, Keyfitz 1977).
## (See p205 of Trefethen and Bau for this algorithm, which the authors note is
## not a very effective method for finding eigenvalues/eigenvectors.)
## Here we'll use just use eigen() to get our eigenvalues and vectors. This
## gives a reasonably good approximation to the values of lambda_m= 0.9450 and
## r = -0.0565 generated by Crouse.
eig <- eigen(A, symmetric = FALSE)
lambda <- Re(eig$values[1])
(r <- log(lambda))

## The stable stage distribution is given by the right eigenvector (coerced here
## to its real part).
w1 <- Re(eig$vectors[,1])
turtleData <- mutate(turtleData, stage.dist = w1/sum(w1))

ggplot(turtleData, aes(x = stage, y = stage.dist))+
    geom_bar(stat="identity", fill="cornflowerblue", width = 0.8)+
    xlab("Stage")+
    ylab("Proportion of individuals")+
    scale_x_discrete(limits=turtleData$class)+
    #scale_y_continuous(limits=c(0, 1))+
    theme_classic()+
    theme(axis.text.x = element_text(angle = 45, hjust=1, size=12),
          axis.line.x = element_line(lineend = 0.5))

## The reproductive value is given by the left eigenvector, which we get by
## calculating the eigenvectors of the transpose of the projection matrix.
v1 <- eigen(t(A), symmetric = FALSE)$vectors[,1]
repro_value <- v1/v1[1]
repro_value

## Mean reproductive value
repro_value %*% turtleData$stage.dist

## Sensitivity analyses

perm <- rbind(c(1,0), cbind(F=0, S=1:7))
sens.grow <- t(apply(perm, MARGIN = 1, function(x) {
    td <- turtleData %>% mutate(surv.dec = ifelse(stage==x["S"], surv*0.5, surv),
                                fecund.dec = ifelse(x["F"],0.5,1)*fecund,
                                surv.inc = ifelse(stage==x["S"], 0.99, surv),
                                fecund.inc = ifelse(x["F"],1.5,1)*fecund)

    A <- with(td, createProjectionMatrix(surv.dec, fecund.dec, stage.length))
    eig <- eigen(A, symmetric = FALSE)
    r.dec <- Re(log(eig$values[1]))

    A <- with(td, createProjectionMatrix(surv.inc, fecund.inc, stage.length))
    eig <- eigen(A, symmetric = FALSE)
    r.inc <- Re(log(eig$values[1]))

    return(c(grow.dec=r.dec, grow.inc=r.inc))
}))
sens.grow <- data.frame(perm,sens.grow)

lim=c(min(sens.grow$grow.dec, sens.grow$grow.inc),
      max(sens.grow$grow.dec, sens.grow$grow.inc))

p1 <- ggplot(sens.grow, aes(x = S+1, y = grow.dec))+
    geom_bar(stat="identity", position = "identity",
             fill="grey", width = 0.8)+
    geom_abline(slope = 0, intercept = 0)+
    geom_abline(slope = 0, intercept = r, linetype="dotted")+
    ggtitle("Decrease in fecundity or survivorship")+
    xlab("Vital rate parameter")+
    ylab("Intrinic rate of increase")+
    scale_x_discrete(limits=c("fecundity", as.character(turtleData$class)))+
    scale_y_continuous(limits=lim)+
    theme_classic()+
    theme(axis.text.x = element_text(angle = 45, hjust=1, size=10),
          axis.title = element_text(hjust=0.5),
          title = element_text(size=9.5, face='bold'))

p2 <- ggplot(sens.grow, aes(x = S+1, y = grow.inc))+
    geom_bar(stat="identity", position = "identity",
             fill="grey", width = 0.8)+
    geom_abline(slope = 0, intercept = 0)+
    geom_abline(slope = 0, intercept = r, linetype="dotted")+
    ggtitle("Increase in fecundity or survivorship")+
    xlab("Vital rate parameter")+
    ylab("Intrinic rate of increase")+
    scale_x_discrete(limits=c("fecundity", as.character(turtleData$class)))+
    scale_y_continuous(limits=lim)+
    theme_classic()+
    theme(axis.text.x = element_text(angle = 45, hjust=1, size=10),
          axis.title = element_text(hjust=0.5),
          title = element_text(size=9.5, face='bold'))

grid.arrange(p1, p2, ncol=1)
